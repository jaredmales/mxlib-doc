<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mxlib: Power Spectra</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<!-- ... other metadata & script includes ... -->
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">mxlib
   </div>
   <div id="projectbrief">c++ tools for analyzing astronomical data and other tasks by Jared R. Males. [<a href="https://github.com/jaredmales/mxlib">git repo</a>]</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__psds.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#groups">Modules</a>  </div>
  <div class="headertitle"><div class="title">Power Spectra<div class="ingroups"><a class="el" href="group__signal__processing.html">Signal Processing</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader"> </h2>
<p>Tools for generating and manipulating power spectra</p>
<p>The mxlib PSD utilities are based on the variance normalization for PSDs. For a 1-sided 1-dimensional PSD that is  </p><p class="formulaDsp">
\[
\sigma^2 = \int_0^{f_{max}} PSD(f) df
\]
</p>
<p> or for a 2-sided 1-D PSD  </p><p class="formulaDsp">
\[
\sigma^2 = \int_{f_{min}}^{f_{max}} PSD(f) df.
\]
</p>
<p> More generally  </p><p class="formulaDsp">
\[
\sigma^2 = \int_{\vec{k}} PSD(\vec{k}) d\vec{k}.
\]
</p>
 <table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmx_1_1sigproc_1_1averagePeriodogram.html">mx::sigproc::averagePeriodogram&lt; realT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the average periodogram of a time-series.  <a href="classmx_1_1sigproc_1_1averagePeriodogram.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmx_1_1sigproc_1_1psdVarMean.html">mx::sigproc::psdVarMean&lt; paramsT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the variance of the mean for a process given its PSD.  <a href="structmx_1_1sigproc_1_1psdVarMean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="groups" name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__arpsds" id="r_group__arpsds"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arpsds.html">Autoregressive Power Spectra</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__psd__filter" id="r_group__psd__filter"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__psd__filter.html">PSD Filter</a></td></tr>
<tr class="memdesc:group__psd__filter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filtering with a PSD to generate correlated noise. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga32e44c6b0cd5ec6927a3f1ca1272a987" name="ga32e44c6b0cd5ec6927a3f1ca1272a987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32e44c6b0cd5ec6927a3f1ca1272a987">&#9670;&#160;</a></span>augment1SidedPSD()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vectorTout , typename vectorTin &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mx::sigproc::augment1SidedPSD </td>
          <td>(</td>
          <td class="paramtype">vectorTout &amp;&#160;</td>
          <td class="paramname"><em>psdTwoSided</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vectorTin &amp;&#160;</td>
          <td class="paramname"><em>psdOneSided</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addZeroFreq</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename vectorTin::value_type&#160;</td>
          <td class="paramname"><em>scale</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Augment a 1-sided PSD to standard 2-sided FFT form. </p>
<p>Allocates psdTwoSided to hold a flipped copy of psdOneSided. Default assumes that psdOneSided[0] corresponds to 0 frequency, but this can be changed by setting zeroFreq to a non-zero value. In this case psdTwoSided[0] is set to 0, and the augmented psd is shifted by 1.</p>
<p>To illustrate, the bins are re-ordered as: </p><pre class="fragment">* {1,2,3,4,5} --&gt; {0,1,2,3,4,5,-4,-3,-2,-1}
* </pre><p>The output is scaled so that the total power remains the same. The 0-freq and Nyquist freq are not scaled.</p>
<p>Entries in psdOneSided are cast to the value_type of psdTwoSided, for instance to allow for conversion to complex type.</p>
<dl class="test"><dt><b><a class="el" href="test.html#_test000051">Test:</a></b></dt><dd>Verify scaling and normalization of augment1SidedPSD <a class="el" href="psdUtils__test_8cpp.html#tests_sigproc_psdUtils_augment1SidedPSD">[test doc]</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">psdTwoSided</td><td>on return contains the FFT storage order copy of psdOneSided.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">psdOneSided</td><td>the one-sided PSD to augment  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addZeroFreq</td><td>[optional] set to true if psdOneSided does not contain a zero frequency component.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scale</td><td>[optional] value to scale the input by when copying to the output. The default 0.5 re-normalizes for a 2-sided PSD. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="psdUtils_8hpp_source.html#l00834">834</a> of file <a class="el" href="psdUtils_8hpp_source.html">psdUtils.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="structmx_1_1AO_1_1analysis_1_1clAOLinearPredictor.html#a2da559a2955e86a811e76a447c05acdc">mx::AO::analysis::clAOLinearPredictor&lt; _realT &gt;::calcCoefficients()</a>, <a class="el" href="structmx_1_1AO_1_1analysis_1_1fourierTemporalPSD.html#ad1dc6cada4b345bdd99a9b0c40f9f249">mx::AO::analysis::fourierTemporalPSD&lt; _realT, aosysT &gt;::intensityPSD()</a>, <a class="el" href="psdUtils__test_8cpp.html#a6af36a12d21a95701be235636fc905c7">SCENARIO()</a>, <a class="el" href="psdFilter__test_8cpp.html#a13a207e4a3306af840292eb80499c541">SCENARIO()</a>, and <a class="el" href="speckleAmpPSD_8hpp.html#ae0f6f57d3eea09caad42183533649182">mx::AO::analysis::speckleAmpPSD()</a>.</p>

</div>
</div>
<a id="ga9be4feb5c4ac0b44608a726306b0311a" name="ga9be4feb5c4ac0b44608a726306b0311a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9be4feb5c4ac0b44608a726306b0311a">&#9670;&#160;</a></span>augment1SidedPSDFreq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mx::sigproc::augment1SidedPSDFreq </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>freqTwoSided</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>freqOneSided</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Augment a 1-sided frequency scale to standard FFT form. </p>
<p>Allocates freqTwoSided to hold a flipped copy of freqOneSided. If freqOneSided[0] is not 0, freqTwoSided[0] is set to 0, and the augmented frequency scale is shifted by 1.</p>
<p>Example:</p>
<p>{1,2,3,4,5} --&gt; {0,1,2,3,4,5,-4,-3,-2,-1}</p>
<dl class="test"><dt><b><a class="el" href="test.html#_test000052">Test:</a></b></dt><dd>Verify scaling and normalization of augment1SidedPSD <a class="el" href="psdUtils__test_8cpp.html#tests_sigproc_psdUtils_augment1SidedPSD">[test doc]</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">freqTwoSided</td><td>on return contains the FFT storage order copy of freqOneSided.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freqOneSided</td><td>the one-sided frequency scale to augment </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="psdUtils_8hpp_source.html#l00893">893</a> of file <a class="el" href="psdUtils_8hpp_source.html">psdUtils.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="structmx_1_1AO_1_1analysis_1_1fourierTemporalPSD.html#ad1dc6cada4b345bdd99a9b0c40f9f249">mx::AO::analysis::fourierTemporalPSD&lt; _realT, aosysT &gt;::intensityPSD()</a>, <a class="el" href="psdUtils__test_8cpp.html#a6af36a12d21a95701be235636fc905c7">SCENARIO()</a>, and <a class="el" href="psdFilter__test_8cpp.html#a13a207e4a3306af840292eb80499c541">SCENARIO()</a>.</p>

</div>
</div>
<a id="gad62e6e7fd9fde862c407f3d6613e6374" name="gad62e6e7fd9fde862c407f3d6613e6374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad62e6e7fd9fde862c407f3d6613e6374">&#9670;&#160;</a></span>freq_sampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class realT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">realT mx::sigproc::freq_sampling </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">realT&#160;</td>
          <td class="paramname"><em>f_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the frequency sampling for a grid given maximum dimension and maximum frequency. </p>
<p>The freq_sampling is \( \Delta f = f_{max}/ (0.5*dim) \) where \( f_{max} = 1/(2\Delta t) \) is the maximum frequency and \( dim \) is the size of the grid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>is the size of the grid </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f_max</td><td>is the maximum frequency of the grid</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sampling interval \( \delta f \)</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">realT</td><td>is the real floating point type used for calculations. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="psdUtils_8hpp_source.html#l00202">202</a> of file <a class="el" href="psdUtils_8hpp_source.html">psdUtils.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__psds.html#ga027c78549a6e53f04ad2194e4962c79e">mx::sigproc::frequencyGrid()</a>.</p>

</div>
</div>
<a id="ga027c78549a6e53f04ad2194e4962c79e" name="ga027c78549a6e53f04ad2194e4962c79e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga027c78549a6e53f04ad2194e4962c79e">&#9670;&#160;</a></span>frequencyGrid() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eigenArr , typename realParamT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mx::sigproc::frequencyGrid </td>
          <td>(</td>
          <td class="paramtype">eigenArr &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">realParamT&#160;</td>
          <td class="paramname"><em>drT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">eigenArr *&#160;</td>
          <td class="paramname"><em>k_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">eigenArr *&#160;</td>
          <td class="paramname"><em>k_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a 2-D frequency grid. </p>

<p class="definition">Definition at line <a class="el" href="psdUtils_8hpp_source.html#l00319">319</a> of file <a class="el" href="psdUtils_8hpp_source.html">psdUtils.hpp</a>.</p>

<p class="reference">References <a class="el" href="group__psds.html#gad62e6e7fd9fde862c407f3d6613e6374">mx::sigproc::freq_sampling()</a>.</p>

</div>
</div>
<a id="ga204b4a6d60ae3d3ef3fb53ce2fe71266" name="ga204b4a6d60ae3d3ef3fb53ce2fe71266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga204b4a6d60ae3d3ef3fb53ce2fe71266">&#9670;&#160;</a></span>frequencyGrid() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eigenArr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mx::sigproc::frequencyGrid </td>
          <td>(</td>
          <td class="paramtype">eigenArr &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename eigenArr::Scalar&#160;</td>
          <td class="paramname"><em>dt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a frequency grid. </p>

<p class="definition">Definition at line <a class="el" href="psdUtils_8hpp_source.html#l00395">395</a> of file <a class="el" href="psdUtils_8hpp_source.html">psdUtils.hpp</a>.</p>

<p class="reference">References <a class="el" href="group__psds.html#gae6fad3b6e5cc9118ddea2d061fdefee3">mx::sigproc::frequencyGrid()</a>.</p>

</div>
</div>
<a id="ga505c909ca8b9ba63f1b31056ddb069c2" name="ga505c909ca8b9ba63f1b31056ddb069c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga505c909ca8b9ba63f1b31056ddb069c2">&#9670;&#160;</a></span>frequencyGrid() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eigenArr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mx::sigproc::frequencyGrid </td>
          <td>(</td>
          <td class="paramtype">eigenArr &amp;&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename eigenArr::Scalar&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">eigenArr &amp;&#160;</td>
          <td class="paramname"><em>k_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">eigenArr &amp;&#160;</td>
          <td class="paramname"><em>k_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a frequency grid. </p>

<p class="definition">Definition at line <a class="el" href="psdUtils_8hpp_source.html#l00402">402</a> of file <a class="el" href="psdUtils_8hpp_source.html">psdUtils.hpp</a>.</p>

<p class="reference">References <a class="el" href="group__psds.html#gae6fad3b6e5cc9118ddea2d061fdefee3">mx::sigproc::frequencyGrid()</a>.</p>

</div>
</div>
<a id="gae6fad3b6e5cc9118ddea2d061fdefee3" name="gae6fad3b6e5cc9118ddea2d061fdefee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6fad3b6e5cc9118ddea2d061fdefee3">&#9670;&#160;</a></span>frequencyGrid() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename realT , typename realParamT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int mx::sigproc::frequencyGrid </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; realT &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">realParamT&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fftOrder</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a 1-D frequency grid. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">realT</td><td>a real floating point type </td></tr>
    <tr><td class="paramname">realParamT</td><td>a real floating point type, convenience to avoid double-float confusion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000048">Test:</a></b></dt><dd>Verify creation of a 1D frequency grid <a class="el" href="psdUtils__test_8cpp.html#tests_sigproc_psdUtils_frequencyGrid_1D">[test doc]</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">vec</td><td>vec the pre-allocated vector, on return contains the frequency grid  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>dt the temporal sampling of the time series  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fftOrder</td><td>fftOrder [optional] if true the frequency grid is in FFT order </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="psdUtils_8hpp_source.html#l00262">262</a> of file <a class="el" href="psdUtils_8hpp_source.html">psdUtils.hpp</a>.</p>

<p class="reference">References <a class="el" href="group__error__handling__codes.html#gga337fdc93e37f9c7b71ea95ce9a9b0d24ab2388853acb89632f31e3c33dc909ada">mx::invalidarg</a>, and <a class="el" href="group__error__internal.html#ga2550cf350ec6319a2130187f5c2b85d4">mx::internal::mxlib_error_report()</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__psds.html#ga204b4a6d60ae3d3ef3fb53ce2fe71266">mx::sigproc::frequencyGrid()</a>, <a class="el" href="group__psds.html#ga505c909ca8b9ba63f1b31056ddb069c2">mx::sigproc::frequencyGrid()</a>, <a class="el" href="psdUtils__test_8cpp.html#aa8ca758d0185f4252b5b60e8f1941376">SCENARIO()</a>, and <a class="el" href="psdFilter__test_8cpp.html#a13a207e4a3306af840292eb80499c541">SCENARIO()</a>.</p>

</div>
</div>
<a id="gadcc05de7369c4f959fc7b870640d022e" name="gadcc05de7369c4f959fc7b870640d022e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcc05de7369c4f959fc7b870640d022e">&#9670;&#160;</a></span>kneePSD()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename floatT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int mx::sigproc::kneePSD </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; floatT &gt; &amp;&#160;</td>
          <td class="paramname"><em>psd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; floatT &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">floatT&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">floatT&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">floatT&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a 1-D "knee" PSD. </p>
<p>Populates an Eigen array with</p>
<p class="formulaDsp">
\[
 P(f) = \frac{\beta}{ 1 + (f/f_n)^{\alpha}}
\]
</p>
<p>If you set \( T_0 \le 0 \) and \( t_0 = 0\) this reverts to a simple \( 1/f^\alpha \) law (i.e. it treats this as infinite outer scale and inner scale).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">floatT</td><td>a floating point </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">psd</td><td>the PSD vector, will be resized.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the frequency vector  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>the scaling constant  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fn</td><td>the knee frequency  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>the exponent, by convention \( alpha &gt; 0 \). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="psdUtils_8hpp_source.html#l00716">716</a> of file <a class="el" href="psdUtils_8hpp_source.html">psdUtils.hpp</a>.</p>

</div>
</div>
<a id="gaef03a320a8a7a76a756a72b5b99ba6ff" name="gaef03a320a8a7a76a756a72b5b99ba6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef03a320a8a7a76a756a72b5b99ba6ff">&#9670;&#160;</a></span>normPSD() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename floatT , typename floatParamT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">floatT mx::sigproc::normPSD </td>
          <td>(</td>
          <td class="paramtype">Eigen::Array&lt; floatT, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>psd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Array&lt; floatT, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">floatParamT&#160;</td>
          <td class="paramname"><em>normT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">floatT&#160;</td>
          <td class="paramname"><em>kmin</em> = <code>std::numeric_limits&lt;floatT&gt;::min()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">floatT&#160;</td>
          <td class="paramname"><em>kmax</em> = <code>std::numeric_limits&lt;floatT&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize a 2-D PSD to have a given variance. </p>
<p>A frequency range can be specified for calculating the norm, otherwise the entire PSD is used. The entire PSD is normalized regardless.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">floatT</td><td>the floating point type of the PSD. </td></tr>
    <tr><td class="paramname">floatParamT</td><td>a floating point type, convenience to avoid double-float cofusion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000050">Test:</a></b></dt><dd>Verify scaling and normalization of augment1SidedPSD <a class="el" href="psdUtils__test_8cpp.html#tests_sigproc_psdUtils_augment1SidedPSD">[test doc]</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">psd</td><td>[in.out] the PSD to normalize, will be altered.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>the frequency grid for psd.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normT</td><td>the desired total variance (or integral) of the PSD.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kmin</td><td>[optiona] the minimum frequency of the range over which to normalize.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kmax</td><td>[optiona] the maximum frequency of the range over which to normalize. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="psdUtils_8hpp_source.html#l00503">503</a> of file <a class="el" href="psdUtils_8hpp_source.html">psdUtils.hpp</a>.</p>

</div>
</div>
<a id="gadf1501874337d43b64ea2f3da0537a09" name="gadf1501874337d43b64ea2f3da0537a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf1501874337d43b64ea2f3da0537a09">&#9670;&#160;</a></span>normPSD() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename floatT , typename floatParamT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int mx::sigproc::normPSD </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; floatT &gt; &amp;&#160;</td>
          <td class="paramname"><em>psd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; floatT &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">floatParamT&#160;</td>
          <td class="paramname"><em>normT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">floatT&#160;</td>
          <td class="paramname"><em>fmin</em> = <code>std::numeric_limits&lt;floatT&gt;::min()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">floatT&#160;</td>
          <td class="paramname"><em>fmax</em> = <code>std::numeric_limits&lt;floatT&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize a 1-D PSD to have a given variance. </p>
<p>A frequency range can be specified to calculate the norm, otherwise f[0] to f[f.size()-1] is the range. The entire PSD is normalized regardless.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">floatT</td><td>the floating point type of the PSD. </td></tr>
    <tr><td class="paramname">floatParamT</td><td>a floating point type, convenience to avoid double-float cofusion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000049">Test:</a></b></dt><dd>Verify scaling and normalization of augment1SidedPSD <a class="el" href="psdUtils__test_8cpp.html#tests_sigproc_psdUtils_augment1SidedPSD">[test doc]</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">psd</td><td>[in.out] the PSD to normalize, will be altered.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the frequency points for the PSD  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normT</td><td>the desired total variance (or integral) of the PSD.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmin</td><td>[optiona] the minimum frequency of the range over which to normalize.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmax</td><td>[optiona] the maximum frequency of the range over which to normalize. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="psdUtils_8hpp_source.html#l00453">453</a> of file <a class="el" href="psdUtils_8hpp_source.html">psdUtils.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="structmx_1_1AO_1_1analysis_1_1fourierTemporalPSD.html#ad1dc6cada4b345bdd99a9b0c40f9f249">mx::AO::analysis::fourierTemporalPSD&lt; _realT, aosysT &gt;::intensityPSD()</a>, <a class="el" href="psdUtils__test_8cpp.html#a6af36a12d21a95701be235636fc905c7">SCENARIO()</a>, and <a class="el" href="psdFilter__test_8cpp.html#a13a207e4a3306af840292eb80499c541">SCENARIO()</a>.</p>

</div>
</div>
<a id="ga28474f4d402cb6e95cd16fd6debe704e" name="ga28474f4d402cb6e95cd16fd6debe704e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28474f4d402cb6e95cd16fd6debe704e">&#9670;&#160;</a></span>oneoverf_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename realT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">realT mx::sigproc::oneoverf_norm </td>
          <td>(</td>
          <td class="paramtype">realT&#160;</td>
          <td class="paramname"><em>fmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">realT&#160;</td>
          <td class="paramname"><em>fmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">realT&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the normalization for a 1-D \( 1/|f|^\alpha \) PSD. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmin</td><td>is the minimum non-zero absolute value of frequency </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmax</td><td>is the maximum absolute value of frequencey </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>is the power-law exponent, by convention \( \alpha &gt; 0 \).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the normalization for a 2-sided power law PSD.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">realT</td><td>is the real floating point type used for calculations. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="psdUtils_8hpp_source.html#l00418">418</a> of file <a class="el" href="psdUtils_8hpp_source.html">psdUtils.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__psds.html#ga16e4b43e07eaeb749f091a39cf993c90">mx::sigproc::oneoverf_psd()</a>, and <a class="el" href="group__psds.html#ga424886d0cef466d70ab422d34d2822ce">mx::sigproc::vonKarmanPSD()</a>.</p>

</div>
</div>
<a id="ga16e4b43e07eaeb749f091a39cf993c90" name="ga16e4b43e07eaeb749f091a39cf993c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16e4b43e07eaeb749f091a39cf993c90">&#9670;&#160;</a></span>oneoverf_psd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eigenArrp , typename eigenArrf &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mx::sigproc::oneoverf_psd </td>
          <td>(</td>
          <td class="paramtype">eigenArrp &amp;&#160;</td>
          <td class="paramname"><em>psd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">eigenArrf &amp;&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename eigenArrp::Scalar&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename eigenArrp::Scalar&#160;</td>
          <td class="paramname"><em>beta</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a \( 1/|f|^\alpha \) power spectrum. </p>
<p>Populates an Eigen array with  </p><p class="formulaDsp">
\[
 P(|f| = 0) = 0
\]
</p>
  <p class="formulaDsp">
\[
 P(|f| &gt; 0) = \frac{\beta}{|f|^{\alpha}}
\]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">psd</td><td>is the array to populate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>is a frequency grid, must be the same logical size as psd </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>is the power law exponent, by convention \( alpha &gt; 0 \). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>[optional is a normalization constant to multiply the raw spectrum by. If beta==-1 (default) then the PSD is normalized using <a class="el" href="group__psds.html#ga28474f4d402cb6e95cd16fd6debe704e">oneoverf_norm</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">eigenArrp</td><td>is the Eigen-like array type of the psd </td></tr>
    <tr><td class="paramname">eigenArrf</td><td>is the Eigen-like array type of the frequency grid </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="psdUtils_8hpp_source.html#l00586">586</a> of file <a class="el" href="psdUtils_8hpp_source.html">psdUtils.hpp</a>.</p>

<p class="reference">References <a class="el" href="group__psds.html#ga28474f4d402cb6e95cd16fd6debe704e">mx::sigproc::oneoverf_norm()</a>.</p>

</div>
</div>
<a id="ga54f28b5b8ac4cba70ac63bd3a0ba3343" name="ga54f28b5b8ac4cba70ac63bd3a0ba3343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54f28b5b8ac4cba70ac63bd3a0ba3343">&#9670;&#160;</a></span>oneoverk_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename realT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">realT mx::sigproc::oneoverk_norm </td>
          <td>(</td>
          <td class="paramtype">realT&#160;</td>
          <td class="paramname"><em>kmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">realT&#160;</td>
          <td class="paramname"><em>kmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">realT&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the normalization for a 2-D \( 1/|k|^\alpha \) PSD. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">kmin</td><td>is the minimum non-zero absolute value of frequency </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kmax</td><td>is the maximum absolute value of frequencey </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>is the power-law exponent, by convention \( \alpha &gt; 0 \).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the normalization for a 2-D, 2-sided power law PSD.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">realT</td><td>is the real floating point type used for calculations. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="psdUtils_8hpp_source.html#l00436">436</a> of file <a class="el" href="psdUtils_8hpp_source.html">psdUtils.hpp</a>.</p>

</div>
</div>
<a id="gaa1e70516ded906911c0f18ac466b272d" name="gaa1e70516ded906911c0f18ac466b272d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1e70516ded906911c0f18ac466b272d">&#9670;&#160;</a></span>psdVar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename realT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">realT mx::sigproc::psdVar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; realT &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; realT &gt; &amp;&#160;</td>
          <td class="paramname"><em>PSD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">realT&#160;</td>
          <td class="paramname"><em>half</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the variance of a 1-D PSD. </p>
<p>By default uses trapezoid rule integration. This can be changed to mid-point integration.</p>
<p>If f.back() &lt; 0, then a 2-sided PSD in FFT storage order is assumed. Otherwise, PSD is treated as 1-sided.</p>
<dl class="section return"><dt>Returns</dt><dd>the variance of a PSD (the integral).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">realT</td><td>the real floating point type</td></tr>
  </table>
  </dd>
</dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000047">Test:</a></b></dt><dd>Scenario: calculating variance from a 1D PSD. <a class="el" href="psdUtils__test_8cpp.html#tests_sigproc_psdUtils_psdVar_1D">[test doc]</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the frequency scale of the PSD.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PSD</td><td>the PSD to integrate.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">half</td><td>[optional] controls if trapezoid (0.5) or mid-point (1.0) integration is used. Do not use other values. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="psdUtils_8hpp_source.html#l00138">138</a> of file <a class="el" href="psdUtils_8hpp_source.html">psdUtils.hpp</a>.</p>

<p class="reference">References <a class="el" href="group__psds.html#ga61cb9edc15367dc46359553a646cd770">mx::sigproc::psdVar1sided()</a>, and <a class="el" href="group__psds.html#gaaf6cadd738aedf81b21cdd406ce63973">mx::sigproc::psdVar2sided()</a>.</p>

<p class="reference">Referenced by <a class="el" href="structmx_1_1AO_1_1analysis_1_1fourierTemporalPSD.html#a10c7c4b740653542cb508fe2cbf9d291">mx::AO::analysis::fourierTemporalPSD&lt; _realT, aosysT &gt;::analyzePSDGrid()</a>, <a class="el" href="structmx_1_1AO_1_1analysis_1_1fourierTemporalPSD.html#ad1dc6cada4b345bdd99a9b0c40f9f249">mx::AO::analysis::fourierTemporalPSD&lt; _realT, aosysT &gt;::intensityPSD()</a>, <a class="el" href="group__psds.html#gaef47718eab8560f420d589d44bd63b49">mx::sigproc::rebin1SidedPSD()</a>, <a class="el" href="psdUtils__test_8cpp.html#a6af36a12d21a95701be235636fc905c7">SCENARIO()</a>, <a class="el" href="psdUtils__test_8cpp.html#a7419701a8b71f52a62b3b32a9d29bb5e">SCENARIO()</a>, and <a class="el" href="speckleAmpPSD_8hpp.html#ae0f6f57d3eea09caad42183533649182">mx::AO::analysis::speckleAmpPSD()</a>.</p>

</div>
</div>
<a id="ga61cb9edc15367dc46359553a646cd770" name="ga61cb9edc15367dc46359553a646cd770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61cb9edc15367dc46359553a646cd770">&#9670;&#160;</a></span>psdVar1sided()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename realT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">realT mx::sigproc::psdVar1sided </td>
          <td>(</td>
          <td class="paramtype">realT&#160;</td>
          <td class="paramname"><em>df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const realT *&#160;</td>
          <td class="paramname"><em>PSD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">realT&#160;</td>
          <td class="paramname"><em>half</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the variance of a 1-D, 1-sided PSD. </p>
<p>By default uses trapezoid rule integration. This can be changed to mid-point integration.</p>
<dl class="section return"><dt>Returns</dt><dd>the variance of a PSD (the integral).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">realT</td><td>the real floating point type</td></tr>
  </table>
  </dd>
</dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000045">Test:</a></b></dt><dd>Scenario: calculating variance from a 1D PSD <a class="el" href="psdUtils__test_8cpp.html#tests_sigproc_psdUtils_psdVar_1D">[test doc]</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">df</td><td>the frequency scale of the PSD  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PSD</td><td>the PSD to integrate.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>the size of the PSD vector  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">half</td><td>[optional] controls if trapezoid (0.5) or mid-point (1.0) integration is used. Do not use other values. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="psdUtils_8hpp_source.html#l00066">66</a> of file <a class="el" href="psdUtils_8hpp_source.html">psdUtils.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="classmx_1_1sigproc_1_1averagePeriodogram.html#a57dc74dd38c5bc17dc1383ec9b51083c">mx::sigproc::averagePeriodogram&lt; realT &gt;::operator()()</a>, and <a class="el" href="group__psds.html#gaa1e70516ded906911c0f18ac466b272d">mx::sigproc::psdVar()</a>.</p>

</div>
</div>
<a id="gaaf6cadd738aedf81b21cdd406ce63973" name="gaaf6cadd738aedf81b21cdd406ce63973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf6cadd738aedf81b21cdd406ce63973">&#9670;&#160;</a></span>psdVar2sided()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename realT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">realT mx::sigproc::psdVar2sided </td>
          <td>(</td>
          <td class="paramtype">realT&#160;</td>
          <td class="paramname"><em>df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const realT *&#160;</td>
          <td class="paramname"><em>PSD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">realT&#160;</td>
          <td class="paramname"><em>half</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the variance of a 1-D, 2-sided PSD. </p>
<p>By default uses trapezoid rule integration. This can be changed to mid-point integration.</p>
<p>Assumes the 2-sided PSD is in standard FFT storage order, and that sz is even.</p>
<dl class="section return"><dt>Returns</dt><dd>the variance of a PSD (the integral).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">realT</td><td>the real floating point type</td></tr>
  </table>
  </dd>
</dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000046">Test:</a></b></dt><dd>Scenario: calculating variance from a 1D PSD. <a class="el" href="psdUtils__test_8cpp.html#tests_sigproc_psdUtils_psdVar_1D">[test doc]</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">df</td><td>the frequency scale of the PSD  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PSD</td><td>the PSD to integrate.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sz</td><td>the size of the PSD vector  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">half</td><td>[optional] controls if trapezoid (0.5) or mid-point (1.0) integration is used. Do not use other values. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="psdUtils_8hpp_source.html#l00101">101</a> of file <a class="el" href="psdUtils_8hpp_source.html">psdUtils.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="group__psds.html#gaa1e70516ded906911c0f18ac466b272d">mx::sigproc::psdVar()</a>.</p>

</div>
</div>
<a id="ga38d23967b6fb4e964ae47e3577df1e48" name="ga38d23967b6fb4e964ae47e3577df1e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38d23967b6fb4e964ae47e3577df1e48">&#9670;&#160;</a></span>psdVarDisabled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eigenArrT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">eigenArrT::Scalar mx::sigproc::psdVarDisabled </td>
          <td>(</td>
          <td class="paramtype">eigenArrT &amp;&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">eigenArrT &amp;&#160;</td>
          <td class="paramname"><em>PSD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trap</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the variance of a PSD. </p>
<p>By default uses trapezoid rule integration. This can be changed to mid-point integration.</p>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.</p>
<dl class="section return"><dt>Returns</dt><dd>the variance of a PSD (the integral).</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">realT</td><td>the real floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>the frequency scale of the PSD  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PSD</td><td>the PSD to integrate.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trap</td><td>[optional] controls if trapezoid (true) or mid-point (false) integration is used. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="psdUtils_8hpp_source.html#l00164">164</a> of file <a class="el" href="psdUtils_8hpp_source.html">psdUtils.hpp</a>.</p>

</div>
</div>
<a id="gaef47718eab8560f420d589d44bd63b49" name="gaef47718eab8560f420d589d44bd63b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef47718eab8560f420d589d44bd63b49">&#9670;&#160;</a></span>rebin1SidedPSD()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename realT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int mx::sigproc::rebin1SidedPSD </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; realT &gt; &amp;&#160;</td>
          <td class="paramname"><em>binFreq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; realT &gt; &amp;&#160;</td>
          <td class="paramname"><em>binPSD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; realT &gt; &amp;&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; realT &gt; &amp;&#160;</td>
          <td class="paramname"><em>PSD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">realT&#160;</td>
          <td class="paramname"><em>binSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>binAtZero</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rebin a PSD, including its frequency scale, to a larger frequency bin size (fewer bins) </p>
<p>The rebinning uses trapezoid integration within bins to ensure minimum signal loss.</p>
<p>Maintains DFT sampling. That is, if initial frequency grid is 0,0.1,0.2... and the binSize is 1.0, the new grid will be 0,1,2 (as opposed to 0.5, 1.5, 2.5).</p>
<p>This introduces a question of what to do with first half-bin, which includes 0. It can be integrated (binAtZero = true, the default). This may cause inaccurate behavior if the value of the PSD when f=0 is important (e.g. when analyzing correlated noise), so setting binAtZero=false causes the f=0 value to be copied (using the nearest neighbor if no f=0 point is in the input.</p>
<p>The last half bin is always integrated.</p>
<p>The output is variance normalized to match the input variance.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">realT</td><td>the real floating point type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">binFreq</td><td>the binned frequency scale, resized.  </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">binPSD</td><td>the binned PSD, resized.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>the frequency scale of the PSD to bin.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">PSD</td><td>the PSD to bin.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">binSize</td><td>in same units as freq  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">binAtZero</td><td>[optional] controls whether the zero point is binned or copied. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="psdUtils_8hpp_source.html#l00950">950</a> of file <a class="el" href="psdUtils_8hpp_source.html">psdUtils.hpp</a>.</p>

<p class="reference">References <a class="el" href="group__psds.html#gaa1e70516ded906911c0f18ac466b272d">mx::sigproc::psdVar()</a>.</p>

</div>
</div>
<a id="ga424886d0cef466d70ab422d34d2822ce" name="ga424886d0cef466d70ab422d34d2822ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga424886d0cef466d70ab422d34d2822ce">&#9670;&#160;</a></span>vonKarmanPSD() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename eigenArrp , typename eigenArrf , typename alphaT , typename L0T , typename l0T , typename betaT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mx::sigproc::vonKarmanPSD </td>
          <td>(</td>
          <td class="paramtype">eigenArrp &amp;&#160;</td>
          <td class="paramname"><em>psd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">eigenArrf &amp;&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">alphaT&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">L0T&#160;</td>
          <td class="paramname"><em>L0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">l0T&#160;</td>
          <td class="paramname"><em>l0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">betaT&#160;</td>
          <td class="paramname"><em>beta</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a von Karman power spectrum. </p>
<p>Populates an Eigen array with</p>
<p class="formulaDsp">
\[
 P(k) = \frac{\beta}{ (k^2 + (1/L_0)^2)^{\alpha/2}} e^{ - k^2 l_0^2}
\]
</p>
<p>If you set \( L_0 \le 0 \) and \( l_0 = 0\) this reverts to a simple \( 1/f^\alpha \) law (i.e. it treats this as infinite outer scale and inner scale).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">psd</td><td>is the array to populate, allocated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">freq</td><td>is a frequency grid, must be the same logical size as psd </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>is the power law exponent, by convention \( alpha &gt; 0 \). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L0</td><td>[optional] is the outer scale. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">l0</td><td>[optional] is the inner scale. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>[optional] is a normalization constant to multiply the raw spectrum by. If beta==-1 (default) then the PSD is normalized using <a class="el" href="group__psds.html#ga28474f4d402cb6e95cd16fd6debe704e">oneoverf_norm</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">eigenArrp</td><td>is the Eigen array type of the psd </td></tr>
    <tr><td class="paramname">eigenArrf</td><td>is the Eigen array type of the frequency grid </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="psdUtils_8hpp_source.html#l00758">758</a> of file <a class="el" href="psdUtils_8hpp_source.html">psdUtils.hpp</a>.</p>

<p class="reference">References <a class="el" href="group__psds.html#ga28474f4d402cb6e95cd16fd6debe704e">mx::sigproc::oneoverf_norm()</a>.</p>

</div>
</div>
<a id="gac00759aa1cfb04ef3b57f0c319b8175b" name="gac00759aa1cfb04ef3b57f0c319b8175b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac00759aa1cfb04ef3b57f0c319b8175b">&#9670;&#160;</a></span>vonKarmanPSD() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename floatT , typename floatfT , typename alphaT , typename T0T  = double, typename t0T  = double, typename betaT  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__error__handling__codes.html#ga337fdc93e37f9c7b71ea95ce9a9b0d24">mx::error_t</a> mx::sigproc::vonKarmanPSD </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; floatT &gt; &amp;&#160;</td>
          <td class="paramname"><em>psd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; floatfT &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">alphaT&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T0T&#160;</td>
          <td class="paramname"><em>T0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">t0T&#160;</td>
          <td class="paramname"><em>t0</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">betaT&#160;</td>
          <td class="paramname"><em>beta</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a 1-D von Karman power spectrum. </p>
<p>Populates an Eigen array with</p>
<p class="formulaDsp">
\[
 P(f) = \frac{\beta}{ (f^2 + (1/T_0)^2)^{\alpha/2}} e^{ - f^2 t_0^2}
\]
</p>
<p>If you set \( T_0 \le 0 \) and \( t_0 = 0\) this reverts to a simple \( 1/f^\alpha \) law (i.e. it treats this as infinite outer scale and inner scale).</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__error__handling__codes.html#gga337fdc93e37f9c7b71ea95ce9a9b0d24a0d2e59ba32a5619357373d2a0594821f" title="No error has occurred.">error_t::noerror</a> on success</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">floatT</td><td>a floating point </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">psd</td><td>the PSD vector, will be resized.  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>the frequency vector  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>the exponent, by convention \( alpha &gt; 0 \).  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">T0</td><td>the outer scale, default is 0 (not used).  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t0</td><td>the inner scale, default is 0 (not used).  </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>the scaling constant, default is 1 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="psdUtils_8hpp_source.html#l00650">650</a> of file <a class="el" href="psdUtils_8hpp_source.html">psdUtils.hpp</a>.</p>

<p class="reference">References <a class="el" href="group__error__handling__codes.html#gga337fdc93e37f9c7b71ea95ce9a9b0d24a0d2e59ba32a5619357373d2a0594821f">mx::noerror</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Feb 19 2026 23:03:57 for mxlib by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
